const _ = require('lodash');
const log = require('debug')('loopback:connector:elasticsearch');

function buildFilter(modelName, idName, criteria = {}, size = null, offset = null) {
  const self = this;
  log('ESConnector.prototype.buildFilter', 'model', modelName, 'idName', idName,
    'criteria', JSON.stringify(criteria, null, 0));

  if (idName === undefined || idName === null) {
    throw new Error('idName not set!');
  }

  const filter = this.addDefaults(modelName, 'buildFilter');
  filter.body = {};

  if (size !== undefined && size !== null) {
    filter.size = size;
  }
  if (offset !== undefined && offset !== null) {
    filter.from = offset;
  }

  if (criteria) {
    // `criteria` is set by app-devs, therefore, it overrides any connector level arguments
    if (criteria.limit !== undefined && criteria.limit !== null) {
      filter.size = criteria.limit;
    }
    if (criteria.skip !== undefined && criteria.skip !== null) {
      filter.from = criteria.skip;
    } else if (criteria.offset !== undefined
        && criteria.offset !== null) { // use offset as an alias for skip
      filter.from = criteria.offset;
    }
    if (criteria.fields) {
      // Elasticsearch _source filtering code
      if (Array.isArray(criteria.fields) || typeof criteria.fields === 'string') {
        // eslint-disable-next-line no-underscore-dangle
        filter.body._source = criteria.fields;
      } else if (typeof criteria.fields === 'object' && Object.keys(criteria.fields).length > 0) {
        // eslint-disable-next-line no-underscore-dangle
        filter.body._source = {
          includes: _.map(_.pickBy(criteria.fields, (v) => v === true), (v, k) => k),
          excludes: _.map(_.pickBy(criteria.fields, (v) => v === false), (v, k) => k)
        };
      }
    }
    if (criteria.searchafter && Array.isArray(criteria.searchafter)
    && criteria.searchafter.length) {
      filter.body.search_after = criteria.searchafter;
      filter.from = undefined;
    }
    if (criteria.order) {
      log('ESConnector.prototype.buildFilter', 'will delegate sorting to buildOrder()');
      filter.body.sort = self.buildOrder(modelName, idName, criteria.order);
    } else {
      // eslint-disable-next-line no-underscore-dangle
      const modelProperties = this._models[modelName].properties;
      if (idName === 'id' && modelProperties.id.generated) {
        // filter.body.sort = ['_id']; // requires mapping to contain: ...
        // ...'_id' : {'index' : 'not_analyzed','store' : true}
        log('ESConnector.prototype.buildFilter', 'will sort on _id by default when IDs are meant to be auto-generated by elasticsearch');
        filter.body.sort = ['_id'];
      } else {
        log('ESConnector.prototype.buildFilter', 'will sort on loopback specified IDs');
        filter.body.sort = [idName]; // default sort should be based on fields marked as id
      }
    }
    if (criteria.where) {
      filter.body.query = self.buildWhere(modelName, idName, criteria.where).query;
    } else if (_.keys(criteria).length === 0) {
      filter.body = {
        query: {
          bool: {
            must: {
              match_all: {}
            },
            filter: [{
              term: {
                'docType.keyword': modelName
              }
            }]
          }
        }
      };
    } else if (!Object.prototype.hasOwnProperty.call(criteria, 'where')) {
      // For queries without 'where' filter, add docType filter
      filter.body.query = self.buildWhere(modelName, idName, criteria.where || {}).query;
    }
    // TODO: native query support must be secured to restrict data access to request model
    /* if (criteria.native) {
      filter.body = criteria.native; // assume that the developer has provided ES compatible DSL
    } */
  }

  log('ESConnector.prototype.buildFilter', 'constructed', JSON.stringify(filter, null, 0));
  return filter;
}

module.exports.buildFilter = buildFilter;
